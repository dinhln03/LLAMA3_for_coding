
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import flow_action_list
class flow_id(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module brocade-openflow-operational - based on the path /openflow-state/flow-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__flow_id','__priority','__status','__in_port','__in_vlan','__source_mac','__destination_mac','__ether_type','__ip_protocol','__ip_protocol_source_port','__ip_protocol_destination_port','__source_ip','__destination_ip','__source_ipv6','__destination_ipv6','__instructions','__action_data','__meter_id','__vlan_upbits','__nw_tos','__source_ip_mask','__destination_ip_mask','__total_packets','__total_bytes','__flow_action_list',)

  _yang_name = 'flow-id'
  _rest_name = 'flow-id'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    path_helper_ = kwargs.pop("path_helper", None)
    if path_helper_ is False:
      self._path_helper = False
    elif path_helper_ is not None and isinstance(path_helper_, xpathhelper.YANGPathHelper):
      self._path_helper = path_helper_
    elif hasattr(self, "_parent"):
      path_helper_ = getattr(self._parent, "_path_helper", False)
      self._path_helper = path_helper_
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__ether_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="ether-type", rest_name="ether-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__destination_ipv6 = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-ipv6", rest_name="destination-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__total_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-bytes", rest_name="total-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint64', is_config=False)
    self.__ip_protocol_destination_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol-destination-port", rest_name="ip-protocol-destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__action_data = YANGDynClass(base=unicode, is_leaf=True, yang_name="action-data", rest_name="action-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__ip_protocol_source_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol-source-port", rest_name="ip-protocol-source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__total_packets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-packets", rest_name="total-packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint64', is_config=False)
    self.__source_ipv6 = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ipv6", rest_name="source-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__flow_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="flow-id", rest_name="flow-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__destination_mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-mac", rest_name="destination-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__in_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="in-port", rest_name="in-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-flow-pending-modify': {'value': 3}, u'dcm-flow-programmed': {'value': 4}, u'dcm-flow-pending-add': {'value': 1}, u'dcm-flow-pending-delete': {'value': 2}, u'dcm-flow-not-programmed': {'value': 0}},), is_leaf=True, yang_name="status", rest_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='flow-status', is_config=False)
    self.__destination_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-ip", rest_name="destination-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__ip_protocol = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol", rest_name="ip-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__flow_action_list = YANGDynClass(base=YANGListType("action_idx",flow_action_list.flow_action_list, yang_name="flow-action-list", rest_name="flow-action-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='action-idx', extensions={u'tailf-common': {u'callpoint': u'openflow-flow-action', u'cli-suppress-show-path': None}}), is_container='list', yang_name="flow-action-list", rest_name="flow-action-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-action', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    self.__source_mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-mac", rest_name="source-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__nw_tos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nw-tos", rest_name="nw-tos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__meter_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="meter-id", rest_name="meter-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    self.__instructions = YANGDynClass(base=unicode, is_leaf=True, yang_name="instructions", rest_name="instructions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__in_vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="in-vlan", rest_name="in-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__source_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ip", rest_name="source-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__source_ip_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ip-mask", rest_name="source-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__destination_ip_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-ip-mask", rest_name="destination-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    self.__vlan_upbits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlan-upbits", rest_name="vlan-upbits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'openflow-state', u'flow-id']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'openflow-state', u'flow-id']

  def _get_flow_id(self):
    """
    Getter method for flow_id, mapped from YANG variable /openflow_state/flow_id/flow_id (uint32)

    YANG Description: Flow ID
    """
    return self.__flow_id
      
  def _set_flow_id(self, v, load=False):
    """
    Setter method for flow_id, mapped from YANG variable /openflow_state/flow_id/flow_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_id() directly.

    YANG Description: Flow ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="flow-id", rest_name="flow-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="flow-id", rest_name="flow-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__flow_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_id(self):
    self.__flow_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="flow-id", rest_name="flow-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /openflow_state/flow_id/priority (uint32)

    YANG Description: Priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /openflow_state/flow_id/priority (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="priority", rest_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /openflow_state/flow_id/status (flow-status)

    YANG Description: Status
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /openflow_state/flow_id/status (flow-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-flow-pending-modify': {'value': 3}, u'dcm-flow-programmed': {'value': 4}, u'dcm-flow-pending-add': {'value': 1}, u'dcm-flow-pending-delete': {'value': 2}, u'dcm-flow-not-programmed': {'value': 0}},), is_leaf=True, yang_name="status", rest_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='flow-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with flow-status""",
          'defined-type': "brocade-openflow-operational:flow-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-flow-pending-modify': {'value': 3}, u'dcm-flow-programmed': {'value': 4}, u'dcm-flow-pending-add': {'value': 1}, u'dcm-flow-pending-delete': {'value': 2}, u'dcm-flow-not-programmed': {'value': 0}},), is_leaf=True, yang_name="status", rest_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='flow-status', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dcm-flow-pending-modify': {'value': 3}, u'dcm-flow-programmed': {'value': 4}, u'dcm-flow-pending-add': {'value': 1}, u'dcm-flow-pending-delete': {'value': 2}, u'dcm-flow-not-programmed': {'value': 0}},), is_leaf=True, yang_name="status", rest_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='flow-status', is_config=False)


  def _get_in_port(self):
    """
    Getter method for in_port, mapped from YANG variable /openflow_state/flow_id/in_port (string)

    YANG Description: In Port
    """
    return self.__in_port
      
  def _set_in_port(self, v, load=False):
    """
    Setter method for in_port, mapped from YANG variable /openflow_state/flow_id/in_port (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_port() directly.

    YANG Description: In Port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="in-port", rest_name="in-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_port must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="in-port", rest_name="in-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__in_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_port(self):
    self.__in_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="in-port", rest_name="in-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_in_vlan(self):
    """
    Getter method for in_vlan, mapped from YANG variable /openflow_state/flow_id/in_vlan (string)

    YANG Description: In Vlan
    """
    return self.__in_vlan
      
  def _set_in_vlan(self, v, load=False):
    """
    Setter method for in_vlan, mapped from YANG variable /openflow_state/flow_id/in_vlan (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_vlan() directly.

    YANG Description: In Vlan
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="in-vlan", rest_name="in-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_vlan must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="in-vlan", rest_name="in-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__in_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_vlan(self):
    self.__in_vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="in-vlan", rest_name="in-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_source_mac(self):
    """
    Getter method for source_mac, mapped from YANG variable /openflow_state/flow_id/source_mac (string)

    YANG Description: Source Mac
    """
    return self.__source_mac
      
  def _set_source_mac(self, v, load=False):
    """
    Setter method for source_mac, mapped from YANG variable /openflow_state/flow_id/source_mac (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_mac() directly.

    YANG Description: Source Mac
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-mac", rest_name="source-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_mac must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-mac", rest_name="source-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__source_mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_mac(self):
    self.__source_mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-mac", rest_name="source-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_destination_mac(self):
    """
    Getter method for destination_mac, mapped from YANG variable /openflow_state/flow_id/destination_mac (string)

    YANG Description: Destination Mac
    """
    return self.__destination_mac
      
  def _set_destination_mac(self, v, load=False):
    """
    Setter method for destination_mac, mapped from YANG variable /openflow_state/flow_id/destination_mac (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_mac() directly.

    YANG Description: Destination Mac
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="destination-mac", rest_name="destination-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_mac must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-mac", rest_name="destination-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__destination_mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_mac(self):
    self.__destination_mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-mac", rest_name="destination-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_ether_type(self):
    """
    Getter method for ether_type, mapped from YANG variable /openflow_state/flow_id/ether_type (string)

    YANG Description: Ether type
    """
    return self.__ether_type
      
  def _set_ether_type(self, v, load=False):
    """
    Setter method for ether_type, mapped from YANG variable /openflow_state/flow_id/ether_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ether_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ether_type() directly.

    YANG Description: Ether type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ether-type", rest_name="ether-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ether_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ether-type", rest_name="ether-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__ether_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ether_type(self):
    self.__ether_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="ether-type", rest_name="ether-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_ip_protocol(self):
    """
    Getter method for ip_protocol, mapped from YANG variable /openflow_state/flow_id/ip_protocol (uint32)

    YANG Description: IP Protocol
    """
    return self.__ip_protocol
      
  def _set_ip_protocol(self, v, load=False):
    """
    Setter method for ip_protocol, mapped from YANG variable /openflow_state/flow_id/ip_protocol (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_protocol() directly.

    YANG Description: IP Protocol
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol", rest_name="ip-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_protocol must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol", rest_name="ip-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ip_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_protocol(self):
    self.__ip_protocol = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol", rest_name="ip-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_ip_protocol_source_port(self):
    """
    Getter method for ip_protocol_source_port, mapped from YANG variable /openflow_state/flow_id/ip_protocol_source_port (uint32)

    YANG Description: IP Protocol Source Port
    """
    return self.__ip_protocol_source_port
      
  def _set_ip_protocol_source_port(self, v, load=False):
    """
    Setter method for ip_protocol_source_port, mapped from YANG variable /openflow_state/flow_id/ip_protocol_source_port (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_protocol_source_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_protocol_source_port() directly.

    YANG Description: IP Protocol Source Port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol-source-port", rest_name="ip-protocol-source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_protocol_source_port must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol-source-port", rest_name="ip-protocol-source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ip_protocol_source_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_protocol_source_port(self):
    self.__ip_protocol_source_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol-source-port", rest_name="ip-protocol-source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_ip_protocol_destination_port(self):
    """
    Getter method for ip_protocol_destination_port, mapped from YANG variable /openflow_state/flow_id/ip_protocol_destination_port (uint32)

    YANG Description: IP Protocol Destination Port
    """
    return self.__ip_protocol_destination_port
      
  def _set_ip_protocol_destination_port(self, v, load=False):
    """
    Setter method for ip_protocol_destination_port, mapped from YANG variable /openflow_state/flow_id/ip_protocol_destination_port (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_protocol_destination_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_protocol_destination_port() directly.

    YANG Description: IP Protocol Destination Port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol-destination-port", rest_name="ip-protocol-destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_protocol_destination_port must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol-destination-port", rest_name="ip-protocol-destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__ip_protocol_destination_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_protocol_destination_port(self):
    self.__ip_protocol_destination_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ip-protocol-destination-port", rest_name="ip-protocol-destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_source_ip(self):
    """
    Getter method for source_ip, mapped from YANG variable /openflow_state/flow_id/source_ip (string)

    YANG Description: Source IPv4
    """
    return self.__source_ip
      
  def _set_source_ip(self, v, load=False):
    """
    Setter method for source_ip, mapped from YANG variable /openflow_state/flow_id/source_ip (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ip() directly.

    YANG Description: Source IPv4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-ip", rest_name="source-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ip must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ip", rest_name="source-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__source_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ip(self):
    self.__source_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ip", rest_name="source-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_destination_ip(self):
    """
    Getter method for destination_ip, mapped from YANG variable /openflow_state/flow_id/destination_ip (string)

    YANG Description: Destination IPv4
    """
    return self.__destination_ip
      
  def _set_destination_ip(self, v, load=False):
    """
    Setter method for destination_ip, mapped from YANG variable /openflow_state/flow_id/destination_ip (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ip() directly.

    YANG Description: Destination IPv4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="destination-ip", rest_name="destination-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ip must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-ip", rest_name="destination-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__destination_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ip(self):
    self.__destination_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-ip", rest_name="destination-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_source_ipv6(self):
    """
    Getter method for source_ipv6, mapped from YANG variable /openflow_state/flow_id/source_ipv6 (string)

    YANG Description: Source IPv6 Address
    """
    return self.__source_ipv6
      
  def _set_source_ipv6(self, v, load=False):
    """
    Setter method for source_ipv6, mapped from YANG variable /openflow_state/flow_id/source_ipv6 (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ipv6() directly.

    YANG Description: Source IPv6 Address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-ipv6", rest_name="source-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ipv6 must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ipv6", rest_name="source-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__source_ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ipv6(self):
    self.__source_ipv6 = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ipv6", rest_name="source-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_destination_ipv6(self):
    """
    Getter method for destination_ipv6, mapped from YANG variable /openflow_state/flow_id/destination_ipv6 (string)

    YANG Description: Destination IPv6 Address
    """
    return self.__destination_ipv6
      
  def _set_destination_ipv6(self, v, load=False):
    """
    Setter method for destination_ipv6, mapped from YANG variable /openflow_state/flow_id/destination_ipv6 (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ipv6() directly.

    YANG Description: Destination IPv6 Address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="destination-ipv6", rest_name="destination-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ipv6 must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-ipv6", rest_name="destination-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__destination_ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ipv6(self):
    self.__destination_ipv6 = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-ipv6", rest_name="destination-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_instructions(self):
    """
    Getter method for instructions, mapped from YANG variable /openflow_state/flow_id/instructions (string)

    YANG Description: Instructions
    """
    return self.__instructions
      
  def _set_instructions(self, v, load=False):
    """
    Setter method for instructions, mapped from YANG variable /openflow_state/flow_id/instructions (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instructions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instructions() directly.

    YANG Description: Instructions
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="instructions", rest_name="instructions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instructions must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="instructions", rest_name="instructions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__instructions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instructions(self):
    self.__instructions = YANGDynClass(base=unicode, is_leaf=True, yang_name="instructions", rest_name="instructions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_action_data(self):
    """
    Getter method for action_data, mapped from YANG variable /openflow_state/flow_id/action_data (string)

    YANG Description: Action
    """
    return self.__action_data
      
  def _set_action_data(self, v, load=False):
    """
    Setter method for action_data, mapped from YANG variable /openflow_state/flow_id/action_data (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action_data() directly.

    YANG Description: Action
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="action-data", rest_name="action-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action_data must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="action-data", rest_name="action-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__action_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action_data(self):
    self.__action_data = YANGDynClass(base=unicode, is_leaf=True, yang_name="action-data", rest_name="action-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_meter_id(self):
    """
    Getter method for meter_id, mapped from YANG variable /openflow_state/flow_id/meter_id (uint32)

    YANG Description: Meter id
    """
    return self.__meter_id
      
  def _set_meter_id(self, v, load=False):
    """
    Setter method for meter_id, mapped from YANG variable /openflow_state/flow_id/meter_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_meter_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_meter_id() directly.

    YANG Description: Meter id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="meter-id", rest_name="meter-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """meter_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="meter-id", rest_name="meter-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__meter_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_meter_id(self):
    self.__meter_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="meter-id", rest_name="meter-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_vlan_upbits(self):
    """
    Getter method for vlan_upbits, mapped from YANG variable /openflow_state/flow_id/vlan_upbits (uint32)

    YANG Description: Vlan Priority
    """
    return self.__vlan_upbits
      
  def _set_vlan_upbits(self, v, load=False):
    """
    Setter method for vlan_upbits, mapped from YANG variable /openflow_state/flow_id/vlan_upbits (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_upbits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_upbits() directly.

    YANG Description: Vlan Priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlan-upbits", rest_name="vlan-upbits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_upbits must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlan-upbits", rest_name="vlan-upbits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__vlan_upbits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_upbits(self):
    self.__vlan_upbits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlan-upbits", rest_name="vlan-upbits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_nw_tos(self):
    """
    Getter method for nw_tos, mapped from YANG variable /openflow_state/flow_id/nw_tos (uint32)

    YANG Description: IP DSCP
    """
    return self.__nw_tos
      
  def _set_nw_tos(self, v, load=False):
    """
    Setter method for nw_tos, mapped from YANG variable /openflow_state/flow_id/nw_tos (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nw_tos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nw_tos() directly.

    YANG Description: IP DSCP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nw-tos", rest_name="nw-tos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nw_tos must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nw-tos", rest_name="nw-tos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)""",
        })

    self.__nw_tos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nw_tos(self):
    self.__nw_tos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nw-tos", rest_name="nw-tos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint32', is_config=False)


  def _get_source_ip_mask(self):
    """
    Getter method for source_ip_mask, mapped from YANG variable /openflow_state/flow_id/source_ip_mask (string)

    YANG Description: Source IPv4 Mask
    """
    return self.__source_ip_mask
      
  def _set_source_ip_mask(self, v, load=False):
    """
    Setter method for source_ip_mask, mapped from YANG variable /openflow_state/flow_id/source_ip_mask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ip_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ip_mask() directly.

    YANG Description: Source IPv4 Mask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-ip-mask", rest_name="source-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ip_mask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ip-mask", rest_name="source-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__source_ip_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ip_mask(self):
    self.__source_ip_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ip-mask", rest_name="source-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_destination_ip_mask(self):
    """
    Getter method for destination_ip_mask, mapped from YANG variable /openflow_state/flow_id/destination_ip_mask (string)

    YANG Description: Destination IPv4 Mask
    """
    return self.__destination_ip_mask
      
  def _set_destination_ip_mask(self, v, load=False):
    """
    Setter method for destination_ip_mask, mapped from YANG variable /openflow_state/flow_id/destination_ip_mask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ip_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ip_mask() directly.

    YANG Description: Destination IPv4 Mask
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="destination-ip-mask", rest_name="destination-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ip_mask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-ip-mask", rest_name="destination-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)""",
        })

    self.__destination_ip_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ip_mask(self):
    self.__destination_ip_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-ip-mask", rest_name="destination-ip-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='string', is_config=False)


  def _get_total_packets(self):
    """
    Getter method for total_packets, mapped from YANG variable /openflow_state/flow_id/total_packets (uint64)

    YANG Description: Total Packets
    """
    return self.__total_packets
      
  def _set_total_packets(self, v, load=False):
    """
    Setter method for total_packets, mapped from YANG variable /openflow_state/flow_id/total_packets (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_packets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_packets() directly.

    YANG Description: Total Packets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-packets", rest_name="total-packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_packets must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-packets", rest_name="total-packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint64', is_config=False)""",
        })

    self.__total_packets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_packets(self):
    self.__total_packets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-packets", rest_name="total-packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint64', is_config=False)


  def _get_total_bytes(self):
    """
    Getter method for total_bytes, mapped from YANG variable /openflow_state/flow_id/total_bytes (uint64)

    YANG Description: Total Bytes
    """
    return self.__total_bytes
      
  def _set_total_bytes(self, v, load=False):
    """
    Setter method for total_bytes, mapped from YANG variable /openflow_state/flow_id/total_bytes (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_bytes() directly.

    YANG Description: Total Bytes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-bytes", rest_name="total-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_bytes must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-bytes", rest_name="total-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint64', is_config=False)""",
        })

    self.__total_bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_bytes(self):
    self.__total_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-bytes", rest_name="total-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='uint64', is_config=False)


  def _get_flow_action_list(self):
    """
    Getter method for flow_action_list, mapped from YANG variable /openflow_state/flow_id/flow_action_list (list)

    YANG Description: Details of an action
    """
    return self.__flow_action_list
      
  def _set_flow_action_list(self, v, load=False):
    """
    Setter method for flow_action_list, mapped from YANG variable /openflow_state/flow_id/flow_action_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_action_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_action_list() directly.

    YANG Description: Details of an action
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("action_idx",flow_action_list.flow_action_list, yang_name="flow-action-list", rest_name="flow-action-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='action-idx', extensions={u'tailf-common': {u'callpoint': u'openflow-flow-action', u'cli-suppress-show-path': None}}), is_container='list', yang_name="flow-action-list", rest_name="flow-action-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-action', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_action_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("action_idx",flow_action_list.flow_action_list, yang_name="flow-action-list", rest_name="flow-action-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='action-idx', extensions={u'tailf-common': {u'callpoint': u'openflow-flow-action', u'cli-suppress-show-path': None}}), is_container='list', yang_name="flow-action-list", rest_name="flow-action-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-action', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)""",
        })

    self.__flow_action_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_action_list(self):
    self.__flow_action_list = YANGDynClass(base=YANGListType("action_idx",flow_action_list.flow_action_list, yang_name="flow-action-list", rest_name="flow-action-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='action-idx', extensions={u'tailf-common': {u'callpoint': u'openflow-flow-action', u'cli-suppress-show-path': None}}), is_container='list', yang_name="flow-action-list", rest_name="flow-action-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions={u'tailf-common': {u'callpoint': u'openflow-flow-action', u'cli-suppress-show-path': None}}, namespace='urn:brocade.com:mgmt:brocade-openflow-operational', defining_module='brocade-openflow-operational', yang_type='list', is_config=False)

  flow_id = __builtin__.property(_get_flow_id)
  priority = __builtin__.property(_get_priority)
  status = __builtin__.property(_get_status)
  in_port = __builtin__.property(_get_in_port)
  in_vlan = __builtin__.property(_get_in_vlan)
  source_mac = __builtin__.property(_get_source_mac)
  destination_mac = __builtin__.property(_get_destination_mac)
  ether_type = __builtin__.property(_get_ether_type)
  ip_protocol = __builtin__.property(_get_ip_protocol)
  ip_protocol_source_port = __builtin__.property(_get_ip_protocol_source_port)
  ip_protocol_destination_port = __builtin__.property(_get_ip_protocol_destination_port)
  source_ip = __builtin__.property(_get_source_ip)
  destination_ip = __builtin__.property(_get_destination_ip)
  source_ipv6 = __builtin__.property(_get_source_ipv6)
  destination_ipv6 = __builtin__.property(_get_destination_ipv6)
  instructions = __builtin__.property(_get_instructions)
  action_data = __builtin__.property(_get_action_data)
  meter_id = __builtin__.property(_get_meter_id)
  vlan_upbits = __builtin__.property(_get_vlan_upbits)
  nw_tos = __builtin__.property(_get_nw_tos)
  source_ip_mask = __builtin__.property(_get_source_ip_mask)
  destination_ip_mask = __builtin__.property(_get_destination_ip_mask)
  total_packets = __builtin__.property(_get_total_packets)
  total_bytes = __builtin__.property(_get_total_bytes)
  flow_action_list = __builtin__.property(_get_flow_action_list)


  _pyangbind_elements = {'flow_id': flow_id, 'priority': priority, 'status': status, 'in_port': in_port, 'in_vlan': in_vlan, 'source_mac': source_mac, 'destination_mac': destination_mac, 'ether_type': ether_type, 'ip_protocol': ip_protocol, 'ip_protocol_source_port': ip_protocol_source_port, 'ip_protocol_destination_port': ip_protocol_destination_port, 'source_ip': source_ip, 'destination_ip': destination_ip, 'source_ipv6': source_ipv6, 'destination_ipv6': destination_ipv6, 'instructions': instructions, 'action_data': action_data, 'meter_id': meter_id, 'vlan_upbits': vlan_upbits, 'nw_tos': nw_tos, 'source_ip_mask': source_ip_mask, 'destination_ip_mask': destination_ip_mask, 'total_packets': total_packets, 'total_bytes': total_bytes, 'flow_action_list': flow_action_list, }



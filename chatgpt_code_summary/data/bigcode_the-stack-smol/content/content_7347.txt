#
# PySNMP MIB module CISCO-WAN-FR-CONN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WAN-FR-CONN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:20:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
frameRelay, frChan = mibBuilder.importSymbols("BASIS-MIB", "frameRelay", "frChan")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, iso, TimeTicks, ModuleIdentity, Counter64, ObjectIdentity, Unsigned32, MibIdentifier, Integer32, NotificationType, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "iso", "TimeTicks", "ModuleIdentity", "Counter64", "ObjectIdentity", "Unsigned32", "MibIdentifier", "Integer32", "NotificationType", "Counter32")
TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString")
ciscoWanFrConnMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 47))
ciscoWanFrConnMIB.setRevisions(('2002-09-18 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoWanFrConnMIB.setRevisionsDescriptions(('Initial version of the MIB. The content of this MIB was originally available in CISCO-WAN-AXIPOP-MIB defined using SMIv1. The applicable objects from CISCO-WAN-AXIPOP-MIB are defined using SMIv2 in this MIB. Also the descriptions of some of the objects have been modified.',))
if mibBuilder.loadTexts: ciscoWanFrConnMIB.setLastUpdated('200209180000Z')
if mibBuilder.loadTexts: ciscoWanFrConnMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoWanFrConnMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoWanFrConnMIB.setDescription("The MIB module to configure the Frame Relay connection configuration. Terminologies Used: SIW - Frame-Relay-to ATM Service Interworking. In SIW, the ATM port connected to a frame relay port does not need to be aware that it is connected to an interworking function. This is explained in document FRF.8. NIW - Frame-Relay-to ATM Network Interworking. In NIW, the ATM port connected to a frame relay port does need to be aware that it is connected to an interworking function. PVC - Permanent Virtual Circuit OR Permanent Virtual Connection A frame relay logical link, whose endpoints and class of service are defined by network management. A PVC consists of the originating frame relay network element address, originating DLCI, terminating frame relay network element address and terminating DLCI. This is controlled by PAR(Portable Auto Route) controller. SPVC - Soft Permanent Virtual Circuits. This is a PVC controlled by PNNI Controller. Frame Relay PVC/SPVC end-point/Channel is referred to as frame Relay connection in this MIB. Traffic shaping parameters: CIR, EIR, Bc, Be, DE, Tc, AR corresponding to rate of the physical interface. CIR - Committed Information Rate. This is the rate of traffic that the PVC will support as 'comitted' traffic. The committed rate(in bits per second) at which the ingress access interface trunk interfaces, and egress access interface of a frame relay network transfer information to the destination frame relay end system under normal conditions. The rate is averaged over a minimum time interval Tc. AR - Access Rate The maximum number of bits per second that an end station can transmit into the network is bounded by the acess rate of the user-network interface. The line speed of the user network connection limits the access rate. Bc - Committed Burst Size The maximum amount of data(in bits) that the network agrees to transfer, under normal conditions during a time interval Tc. The data is in bytes in the current implementation. Be - Excess Burst Size The maximum amount of uncommitted data(in bits) in excess of BC that a frame relay network can attempt to deliver during a time interval Tc. This data generally is delivered with a low probability than Bc. The network treats Be data as discard eligible. The data is in bytes in the current implementation. Tc - The committed rate measurement interval. The time interval during which the user can send only BC committed amount of data and BE excess amount of data. EIR - Excess Information Rate This is the bandwidth in excess of CIR the PVC will be allowed to burst on a a given PVC. The average rate at which excess traffic is to be policed. This number is computed based on Bc, Be, CIR and Tc. DE - Discard Eligibility Frame Forwarding Port: Frame Forwarding Ports are identified by portType = frame-forward(3). NOTE: The objects related to frame relay ports are available in ifTable,if ifTable is implemented in service module/card. Following Service Modules support ifTable: FRSM-12 ")
frChanCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1))
frChanCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1), )
if mibBuilder.loadTexts: frChanCnfGrpTable.setStatus('current')
if mibBuilder.loadTexts: frChanCnfGrpTable.setDescription('This table is for configuring connection parameters for frame relay connections.')
frChanCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-FR-CONN-MIB", "chanNum"))
if mibBuilder.loadTexts: frChanCnfGrpEntry.setStatus('current')
if mibBuilder.loadTexts: frChanCnfGrpEntry.setDescription('An entry for each frame relay connection.')
chanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanNum.setStatus('current')
if mibBuilder.loadTexts: chanNum.setDescription('The value of this object identifies the frame relay connection/channel index. Note that the actual range of the index supported by a card depends on the type of card. Supported Range for different Card Types: FRSM-4T1/E1 : Range is 16..271 (256 entries) FRSM-8T1/E1 : Range is 16..1015 (1000 entries) FRSM-T3/E3/HS2/ /HS2B-HSSI/T3B/E3B : Range is 16..2015 (2000 entries) FRSM-2CT3/HS2B-12IN1: Range is 16..4015 (4000 entries) For FRSM12 Card : Range is 16..16015 for Lower 16 bits Upper 16 bits contain Chassis Number and logical slot number.')
chanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3), ("outOfService", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanRowStatus.setStatus('current')
if mibBuilder.loadTexts: chanRowStatus.setDescription('This object is used for adding/modifying/deleting the channel. add(1) : For adding the frame relay connections. delete(2): For deleting frame relay connections. mod(3) : For Modifying frame relay connections. This is also used for uping the connection. outOfService(4) : Bring the Frame relay connection down.')
chanPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanPortNum.setStatus('current')
if mibBuilder.loadTexts: chanPortNum.setDescription("This object refers to the frame relay port on which channel is created. This is a mandatory object for creating the channel. For FRSM12 Card: This object contains the port's ifIndex value. ")
dLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388607))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dLCI.setStatus('current')
if mibBuilder.loadTexts: dLCI.setDescription("The value of this object is the DLCI number of the channel. This is a mandatory object for creating the channel. All the connections on the same port should have a unique DLCI number. Note that if we are adding a channel to a port that has LMI signalling enabled, then we can not use DLCI number 0(ANNEX A & D) and 1023(STRATA LMI). The value of this object can be only 1000 if the portType = frame-forward(3) on which the frame relay connection is being created. That is, only one Frame Relay Connection can be created on a Frame Forwarding Port. For portHeaderLen = twoOctets(1) following restrictions apply. Range supported is '0..1023' DLCI values 0,1007, 1023 can not be used. For portHeaderLen = fourOctets(2) following restrictions apply. Range supported is '0..8388607' DLCI values 0,8257535 can not be used. ")
egressQSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("highPriority", 1), ("lowPriority", 2), ("notSupported", 3))).clone('lowPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressQSelect.setStatus('current')
if mibBuilder.loadTexts: egressQSelect.setDescription('Selects one out of two possible port queues. The default port queue number is 1 which is the high pririty queue. 1 = High priority queue 2 = Low priority queue 3 = Indicates that this entry is not used (eg: in FRSM-VHS, chanServType indicates the channel service type and would determine the queue to which the channel gets mapped) For FRSM12 Card: This object is used to select between the two ATM-COS queues in the egress direction. ')
ingressQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4510, 2097151)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressQDepth.setStatus('current')
if mibBuilder.loadTexts: ingressQDepth.setDescription("This variable sets the max depth for queue, before it starts dropping the cells. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (4510..'ffff'h). ingressQDepth should be greater than ingressQECNThresh and ingressQDEThresh For FRSM12 Card: Not Supported ")
ingressQECNThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(6553)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressQECNThresh.setStatus('current')
if mibBuilder.loadTexts: ingressQECNThresh.setDescription("This variable sets the max depth for queue, before it starts flow control. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). For FRSM12 Card: Not Supported ")
ingressQDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(32767)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressQDEThresh.setStatus('current')
if mibBuilder.loadTexts: ingressQDEThresh.setDescription("This variable sets the max depth for queue, before they become discard eligible. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). For FRSM12 Card: Not Supported ")
egressQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressQDepth.setStatus('current')
if mibBuilder.loadTexts: egressQDepth.setDescription("This variable sets the max depth for queue, before it starts dropping the cells. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). egressQDepth should be greater than egressQDEThresh and egressQECNThresh For FRSM12 Card: Not Supported ")
egressQDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(32767)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressQDEThresh.setStatus('current')
if mibBuilder.loadTexts: egressQDEThresh.setDescription("This variable sets the max depth for queue, before they become discard eligible. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). For FRSM12 Card: Not Supported ")
egressQECNThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(6553)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressQECNThresh.setStatus('current')
if mibBuilder.loadTexts: egressQECNThresh.setDescription("This variable sets the max depth for queue, before it starts flow control. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). For FRSM12 Card: Not Supported ")
deTaggingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deTaggingEnable.setStatus('current')
if mibBuilder.loadTexts: deTaggingEnable.setDescription('This object enables/disables the DE tagging. The tagging is enabled only in the ingress direction. For FRSM12 Card: When this object is disabled, the ingress policer will never set the DE bit to 1 in the Frame Relay frames even if the incoming frame exceeds the Bc bucket. ')
cir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000)).clone(2400)).setUnits('bps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cir.setStatus('current')
if mibBuilder.loadTexts: cir.setDescription('The value of this object is equal to the CIR parameter for this frame relay connection. The CIR value have to be less than or equal to the port speed. Any value from 1 to 2399 will be rounded off to 2400. Range supported for different interfaces/card: For E1 interface : Range is 0..2048000 For T1 interface : Range is 0..1536000 For E3 interface : Range is 0..34368000 For T3 interface : Range is 0..44736000 For HSSI : Range is 0..52000000 For FRSM-2CT3 : Range is 0..1536000 For FRSM-HS2B-12IN1: Range is 0..10240000 The CIR value can be 0 only for chanServType = uBR(5). ')
bc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(5100)).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: bc.setStatus('current')
if mibBuilder.loadTexts: bc.setDescription('The value of this object is equal to the committed burst size(BC) parameter for this PVC endpoint. The value of bc can not be 0 when cir is non zero. The value of bc has to be 0 if cir is 0. The peak value for bc in FRSM-VHS cards is (2^21 -1), i.e. 2097151 and for all other cards, it is 65535. For FRSM-VHS cards, the relation between CIR and Bc should be such that Tc is always less than 512 seconds. ')
be = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(5100)).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: be.setStatus('current')
if mibBuilder.loadTexts: be.setDescription('The value of this object is euqal to the excess burst size(Be) parameter for this PVC endpoint. The value be can not be 0 when cir is 0. The peak value for be : For FRSM-VHS and FRSM12 cards is (2^21 -1), i.e. 2097151 and For all other cards, it is 65535. For FRSM-VHS cards, setting the value of 2091751 will cause the policing to be disabled. ')
ibs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibs.setStatus('current')
if mibBuilder.loadTexts: ibs.setDescription('The value of this object is euqal to the excess burst size(Be) parameter for this PVC endpoint. The value of ibs should be less or equal to bc when cir is greater than 0. The value of ibs has to be 0 when cir is 0. The peak value for ibs in FRSM-VHS cards is (2^21 -1), i.e. 2097151 and for all other cards, it is 65535. For FRSM12 Card: Not Supported ')
foreSightEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foreSightEnable.setStatus('current')
if mibBuilder.loadTexts: foreSightEnable.setDescription('This variable enables/disables foreSight option. Following objects can be modified only when this object is set to enable(1): qir, mir, pir The RATE CONTROL FEATURE has to be ON in order to enable foresight and also modify its parameter. For FRSM12 Card: Not Supported ')
qir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 6400000)).clone(160)).setUnits('fastpackets-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: qir.setStatus('current')
if mibBuilder.loadTexts: qir.setDescription('The value of this object is euqal to the quiescent information rate for Foresight. The unit is 1 Cell/Sec = 16 fastpackets/sec. Following information about cps is for reference only: The peak value for qir in FRSM-VHS cards is 285714 cps and for all other cards, it is 10000 cps. For FRSM-VHS cards, cell will be the ATM cell (48 byte payload). For FRSM12 Card: Not Supported')
mir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 6400000)).clone(160)).setUnits('fastpackets-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: mir.setStatus('current')
if mibBuilder.loadTexts: mir.setDescription('The value of this object is euqal to the minimum information rate for Foresight. The unit is 1 Cell/Sec = 16 fastpackets/sec. is equal to 16 fastpackets/sec. Following information about cps is for reference only: The peak value for qir in FRSM-VHS cards is 285714 cps and for all other cards, it is 10000 cps. For FRSM-VHS cards, cell will be the ATM cell (48 byte payload). For FRSM12 Card: Not Supported ')
pir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 6400000)).clone(160)).setUnits('fastpackets-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pir.setStatus('current')
if mibBuilder.loadTexts: pir.setDescription('The value of this object is euqal to the peak information rate for Foresight. The unit is 1 Cell/Sec = 16 fastpackets/sec. is equal to 16 fastpackets/sec. Following information about cps is for reference only: The peak value for qir in FRSM-VHS cards is 285714 cps and for all other cards, it is 10000 cps. For FRSM-VHS cards, cell will be the ATM cell (48 byte payload). For FRSM12 Card: Not Supported ')
chanLocRmtLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanLocRmtLpbkState.setStatus('current')
if mibBuilder.loadTexts: chanLocRmtLpbkState.setDescription('This variable enables or disables the remote loopback for each channel. When you enable this option on a connection (channel) then all the cells that are coming from the network side would be looped back toward the network and all the frames coming from the user side would be dropped. This channel remote loopback has nothing to do with the chanTestType option, each one does a different function. For example, the channel remote loopback is used for looping the data toward the network and if this connection is terminated on an IPX then they can put a test equipment and measure some of the characteristics of the network. For FRSM12 Card: Not Supported ')
chanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testcon", 1), ("testdelay", 2), ("notest", 3))).clone('notest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanTestType.setStatus('current')
if mibBuilder.loadTexts: chanTestType.setDescription('The chanTestType starts testing the continuity or delay of a connection. It sends specific cell patterns toward the network and the terminating end of this connection has to be an MGX8220 or ASI of a BPX in order for this test to be working. The receiving node would loop back when it receives these cells. The test should be done in about couple of seconds. The testcon tests the continuity of the connection and testdelay uses the same test except that it measures for delay through the network. To test the delay follow this procedure: a- set chanTestType to testdelay b- read chanTestState till it is Pass or Fail c- Read chanRTDResult for the delay if it is Pass *Note that the chanTestType would go back to notest when the test is completed To test the continuity follow this procedure: a- set chanTestType to testcon b- read chanTestState till it is Pass or Fail *Note that the chanTestType would go back to notest when the test is completed You CAN NOT select 2 tests back to back, you have to select one and wait for the result and then start the other one. SYNTAX When you select testdelay This is the type of the test 1 = Test Continuity 2 = Test Delay 3 = No Test ')
chanTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4))).clone('notinprogress')).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanTestState.setStatus('current')
if mibBuilder.loadTexts: chanTestState.setDescription('This shows the state of the test When you add a connection then the chanTestState becomes notinprogress and when you select any test, it would go to inprogress state and after it completes the test, it will go to failed or passed state. 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress ')
chanRTDResult = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(65535)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanRTDResult.setStatus('current')
if mibBuilder.loadTexts: chanRTDResult.setDescription('This is round trip delay in milliseconds. When you select testdelay option for the chanTestType, the result of the test that is measured in milliseconds can be read in chanRTDResult. ')
chanType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("frNIW", 1), ("frSIW-transparent", 2), ("frSIW-translate", 3), ("frFUNI", 4), ("frForward", 5), ("frNIWReplace", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanType.setReference('FRF.8')
if mibBuilder.loadTexts: chanType.setStatus('current')
if mibBuilder.loadTexts: chanType.setDescription("The value of this object is used for setting the channel type of a frame relay connection. If set with values frSIW-transparent(2) and frSIW-translate(3), all PVC data is subject to service interworking translation and mapping in both Frame Relay-to-ATM and ATM-to-Frame relay directions. The possible values are : frNIW(1) : Frame-Relay-to ATM Network Interworking(NIW-unicast). The traffic crosses the network as ATM Cells. frSIW-transparent(2): Service InterWorking with out any SDU translation. In transparent mode, the service module does not translate. frSIW-translate(3) : Service InterWorking with SDU translation. In translation mode, service module translates protocol between the FR NLPID encapsulation(RFC 1490) and ATM LCC encapsulation(RFC 1483). Translation mode support includes address resolution by transforming address resolution protocol (ARP, RFC 826) and inverse ARP(RFC 1293) between the frame relay and ATM Formats. frFUNI(4) : Frame based UNI: mode-1a which is ALL5. frForward(5) : frame forwarding. Frame forwarding operates same as standard frame relay except: * 2 byte Q.922 header is not assumed or interpreted. * All frames received are mapped to a specific connection if it exists. Otherwise the frames are dropped. * No DE/CLP or FECN/EFCI mapping is performed. * 'llegal Header count' and 'invalid DLCI' statistics are not kept/applicable. frNIWReplace(6) : Frame Relay network interworking with DLCI in FR-SSCS(Frame Relay Specific Convergence Sublayer)PDU always set to 1022. ")
chanFECNconfig = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mapEFCI", 1), ("setEFCIzero", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanFECNconfig.setReference('FRF.8, section 4.3.1.1')
if mibBuilder.loadTexts: chanFECNconfig.setStatus('current')
if mibBuilder.loadTexts: chanFECNconfig.setDescription('The value of this object specifies how to map from FECN field in the frame Relay PDU to the EFCI field in the ATM cells. This object does not apply to NIW. This is applicable only for SIW. mapEFCI(1) : Maps the FECN bits in frame-relay to EFCI bit in the ATM cells. This value is valid only for SIW. setEFCIzero(2): Set EFCI = 0. Do not map FECN to EFCI.')
chanDEtoCLPmap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mapCLP", 1), ("setCLPzero", 2), ("setCLPone", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanDEtoCLPmap.setReference('FRF.5, FRF.8')
if mibBuilder.loadTexts: chanDEtoCLPmap.setStatus('current')
if mibBuilder.loadTexts: chanDEtoCLPmap.setDescription('The value of this object specifies how to map from DE bit on the Frame Relay side to CLP bit on the ATM side. mapCLP(1) : Map DE bit to CLP bit in ATM cell. setCLPzero(2) : Ignore DE bit. Set CLP to 0. setCLPone(3) : Ignore DE bit. Set CLP to 1. For FRSM12 Card: Should not be mapCLP for chanType of frForward. ')
chanCLPtoDEmap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mapDE", 1), ("setDEzero", 2), ("setDEone", 3), ("ignoreCLP", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanCLPtoDEmap.setReference('FRF.8, section 4.2.2 FRF.5, section 4.4.2')
if mibBuilder.loadTexts: chanCLPtoDEmap.setStatus('current')
if mibBuilder.loadTexts: chanCLPtoDEmap.setDescription('The value of this object enables mapping of Cell Loss Priority(CLP) bit on the ATM Side to Discard Eligibility(DE) bit on the Frame relay side. The possible values are : mapDE(1) : Map CLP bit to DE bit. Valid for SIW and NIW. setDEzero(2) : Ignore CLP. Set DE bit to 0. Valid for SIW. setDEone(3) : Ignore CLP. Set DE bit to 1. Valid for SIW. ignoreCLP(4) : Ignore CLP. No change in receieved DE bit. Valid for NIW. For FRSM12 Card: Should be ignoreCLP for chanType of frForward. Should not be setDEzero/setDEone for chanType of frNIW and frNIWReplace. Should not be ignoreCLP for chanType of frSIW-transparent and frSIW-translate. ')
chanIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(100)).setUnits('percentage').setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanIngrPercentUtil.setStatus('current')
if mibBuilder.loadTexts: chanIngrPercentUtil.setDescription('The ingress utilization on a frame relay connection.')
chanEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(100)).setUnits('percentage').setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanEgrPercentUtil.setStatus('current')
if mibBuilder.loadTexts: chanEgrPercentUtil.setDescription('The egress utilization on a frame relay connection.')
chanEgrSrvRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 52000000)).clone(2400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanEgrSrvRate.setStatus('current')
if mibBuilder.loadTexts: chanEgrSrvRate.setDescription('The value of this object identifies egress CIR value for a frame relay connection. The value of this object must be less than or equal(<=) to the port speed. The value supported depends upon the interface and service module(card) type. For E1 Service Module : Range is 2400..2048000 For T1 Service Module : Range is 2400..1536000 2CT3 Module : For E3 Service Module : Range is 2400..34368000 For T3 Service Module : Range is 2400..44736000 For HSSI Service Module : Range is 2400..52000000 For FRSM12 Card: This object is used only for CAC and the range will be same as the range for cir object. The Maximum value is 44736000m. ')
chanOvrSubOvrRide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanOvrSubOvrRide.setStatus('current')
if mibBuilder.loadTexts: chanOvrSubOvrRide.setDescription('The value of this object enables/disables the oversubscription on a connection. This object allows one to add a new connection on a port even if it is over subscribed. For FRSM12 Card: Not Supported.')
chanFrConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2), ("spvc", 3), ("par", 4), ("pnni", 5), ("tag", 6))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanFrConnType.setStatus('current')
if mibBuilder.loadTexts: chanFrConnType.setDescription('The value of this object is used for configuring connection type of a frame relay connection. The possible values are : pvc(1) : Permanent Virtual Connection svc(2) : Switched Virtual Connection spvc(3) : Soft PVC. par(4) : Portable Auto Route Connection. Valid only for trunk connection pnni(5) : PNNI Connection Valid only for trunk connection tag(6) : Tag/MPLS Connection Valid only for trunk connection For FRSM12 Card: Not Supported.')
frCDRNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCDRNumber.setStatus('current')
if mibBuilder.loadTexts: frCDRNumber.setDescription('The value of this object identifies the CDR(Call Detail Record) number. This is the key to correlate cell/frame counts, start/end record. For FRSM12 Card: Not Supported ')
frLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLocalVpi.setStatus('current')
if mibBuilder.loadTexts: frLocalVpi.setDescription('The value of this object provides the VPI value for the local endpoint. This object in conjunction with frLocalVci and frLocalNSAP represents the local end point of this connection. The service module sets this to value 0.')
frLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLocalVci.setStatus('current')
if mibBuilder.loadTexts: frLocalVci.setDescription("The value of this object provides the VCI value for the local endpoint. This object in conjunction with frLocalVpi and frLocalNSAP represents the local end point of this connection. The service module assigns this value specified in object 'dLCI'.")
frLocalNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 37), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLocalNSAP.setStatus('current')
if mibBuilder.loadTexts: frLocalNSAP.setDescription('The value of this object identifies the NSAP address of the frame relay connection. The value of this object follows the format: Prefix : 13 Bytes Cisco ID : 2 bytes Reserved : 1 byte Slot Number : 1 byte Port Number : 2 bytes ESL : 1 byte For FRSM12 Card: This object will have the NSAP format as required by the PNNI controller ')
frRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRemoteVpi.setStatus('current')
if mibBuilder.loadTexts: frRemoteVpi.setDescription('The value of this object identifies the VPI value of remote end point of this connection. The frRemoteVpi, frRemoteVci and frRemoteNSAP identifies the remote end point of this connection.')
frRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRemoteVci.setStatus('current')
if mibBuilder.loadTexts: frRemoteVci.setDescription('The value of this object identifies the VCI value of remote end point of this connection. The frRemoteVpi, frRemoteVci and frRemoteNSAP identifies the remote end point of this connection.')
frRemoteNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 40), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRemoteNSAP.setStatus('current')
if mibBuilder.loadTexts: frRemoteNSAP.setDescription('The value of this object identifies the NSAP address of the frame relay connection. The value of this object follows the format: Prefix : 13 Bytes Cisco ID : 2 bytes Reserved : 1 byte Slot Number : 1 byte Port Number : 2 bytes ESL : 1 byte.')
frMastership = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frMastership.setStatus('current')
if mibBuilder.loadTexts: frMastership.setDescription(' This is used by PXM to determine if this end point is master or slave, a new type unknown is added to identify the SM in MGX8220 shelf and the SM in MGX shelf. In AXIS shelf, user can still use addchan to add a channel without specifying X/Y/P parameters. But in MGX shelf, if the user uses addchan without X/Y/P set (based on this object being set to type 3 unknown), SPM on PXM will reject the request. It must be supplied in connection setup request. In the feeder mode, this is always set to master. ')
frVpcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2))).clone('vcc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frVpcFlag.setStatus('current')
if mibBuilder.loadTexts: frVpcFlag.setDescription(" This represents the connection type, used for PXM to identify VPC/VCC but FRSM card doesn't use it always set to vcc for FRSM card For FRSM12 Card: For chanFrConnType = pnni(5), this object is set to vcc(2) always.")
frConnServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("notUsed", 3), ("ubr", 4), ("atfr", 5), ("abrstd", 6), ("abrfst", 7), ("vbrrt", 8), ("cbr1", 21), ("vbr1rt", 22), ("vbr2rt", 23), ("vbr3rt", 24), ("vbr1nrt", 25), ("vbr2nrt", 26), ("vbr3nrt", 27), ("ubr1", 28), ("ubr2", 29), ("stdabr", 30), ("cbr2", 31), ("cbr3", 32))).clone('atfr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnServiceType.setStatus('current')
if mibBuilder.loadTexts: frConnServiceType.setDescription("This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 3 ==> Not used 4 ==> Unspecified Bit Rate 5 ==> ATM frame relay 6 ==> standard ABR 7 ==> foresight ABR Note that this is used by PXM card, SV+ doesn't need to set it, if not set in the connection setup request, it'll be defaulted to ATFR type for FRSM. Also to make it compatible with existing AUSM MIB definition, value 3 is not used. The following types are being added for PNNI support. and are based on UNI 4.0 cbr1 (21) - CBR.1 vbr1rt (22) - Real time VBR.1 vbr2rt (23) - Real time VBR.2 vbr3rt (24) - Real time VBR.3 vbr1nrt(25) - Non Real time VBR.1 vbr2nrt(26) - Non Real time VBR.2 vbr3nrt(27) - Non Real time VBR.3 ubr1 (28) - UBR.1 ubr2 (29) - UBR.2 stdabr (30) - TM 4.0 compliant standard ABR cbr2 (31) - CBR.2 cbr3 (32) - CBR.3 For FRSM12 Card: Not Supported. Derived from chanServType. ")
frRoutingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRoutingPriority.setStatus('current')
if mibBuilder.loadTexts: frRoutingPriority.setDescription(' This is used by PXM to determine how important this connection is when selecting connections to route ')
frMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frMaxCost.setStatus('current')
if mibBuilder.loadTexts: frMaxCost.setDescription("The value of this object specifies the Maximum allowed cost. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level. This is not necessary to be provided in the connection setup request, if not provided, the default value 255 will be used. Also the range supported depends upon the controller configured : Controller Range Default Value chanFrConnType = par(2) 1..65535 255 chanFrConnType = pnni(5) 1..2147483647 2147483647. ")
frRestrictTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("norestriction", 1), ("terrestrialTrunk", 2), ("sateliteTrunk", 3))).clone('norestriction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRestrictTrunkType.setStatus('current')
if mibBuilder.loadTexts: frRestrictTrunkType.setDescription(' Restricted trunk type for routing, used by PXM. It specifies that the connection either cannot be routed over satelite trunks, or terrestrial trunks, or it can be on any type of trunk. It is not necessary to be provide in the connection setup request, the default value is norestriction(1). For FRSM12 Card: Not Supported ')
frConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 47), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnPCR.setStatus('current')
if mibBuilder.loadTexts: frConnPCR.setDescription("The value of this object identifies the PCR(Peak Cell Rate). If not provided in the connection setup request, it'll be derived from object 'pir'. For FRSM12 Card: Default value is (1.44 * CIR) ")
frConnRemotePCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 48), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemotePCR.setStatus('current')
if mibBuilder.loadTexts: frConnRemotePCR.setDescription(' Peak cell rate of the other end, if not set, will be set to the same as local end PCR (frConnPCR). However, note that if the CIRs for both local and remote end are set to the different value (i.e., asymmetric conn), then this should be set differently from local end PCR. For FRSM12 Card: Default value is frConnPCR ')
frConnMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 49), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnMCR.setStatus('current')
if mibBuilder.loadTexts: frConnMCR.setDescription(" Minimum cell rate, if not provided in the connection setup request, it'll be derived from object 'mir'. For FRSM12 Card: Default value is frConnPCR ")
frConnRemoteMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 50), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemoteMCR.setStatus('current')
if mibBuilder.loadTexts: frConnRemoteMCR.setDescription(' Minimum cell rate of the other end, if not set, will be set to the same as local end MCR (frConnMCR). However, note that if the CIRs for both local and remote end are set to the different value (i.e., asymmetric conn), then this should be set differently from local end MCR. For FRSM12 Card: Default value is frConnMCR ')
frConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnPercentUtil.setStatus('current')
if mibBuilder.loadTexts: frConnPercentUtil.setDescription("This is the expected long-term utilization of the channel by this end-point. If this is not specified in the connection setup request, it'll be defaulted to 100 percent For FRSM12 Card: Not Supported ")
frConnRemotePercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemotePercentUtil.setStatus('current')
if mibBuilder.loadTexts: frConnRemotePercentUtil.setDescription("This is the expected long-term utilization of the channel by the other end-point. If this is not specified in the connection setup request, it'll be set to be the same as the local end frConnPercentUtil value assuming that the connection is symmetric. In a asymmetric connection, this object is supposed to be set. For FRSM12 Card: Not Supported.")
frConnForeSightEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnForeSightEnable.setStatus('current')
if mibBuilder.loadTexts: frConnForeSightEnable.setDescription("This object is used by the controller(PAR/PNNI/TAG) to set up the Qbin for the connection, if this is not set, it'll be defaulted by SM to the same as foreSightEnable in the end point parameters. For FRSM12 Card: Not Supported.")
frConnFGCRAEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnFGCRAEnable.setStatus('current')
if mibBuilder.loadTexts: frConnFGCRAEnable.setDescription('The value of this object is used for enabling/disabling Frame based GCRA (early packet discard). For FRSM12 Card: Not Supported.')
chanServType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("highpriority", 1), ("rtVBR", 2), ("nrtVBR", 3), ("aBR", 4), ("uBR", 5), ("queue6", 6), ("queue7", 7), ("queue8", 8), ("stdABR", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanServType.setStatus('current')
if mibBuilder.loadTexts: chanServType.setDescription('The value of this object indicates the indicates the class of the connection. 1-High priority (typically CBR connections) 2- real-time VBR 3- non-real time VBR 4- Available Bit Rate 5- Unspecified Bit Rate 9- Standard ABR There are 8 queues actually but only 4 are being used (the 4 queues are for CBR, VBR-rt, <VBR-nrt and ABR>, UBR traffic). This object is suported only in FRSM-VHS and FRSM-8T1E1. For FRSM-8T1E1, a 0 indicates that the connections are of old model type where chanServType object is unused. For FRSM12 Card: The types aBR, queue6, queue7, queue8 are not supported This object can not be modified after a frame relay connection has been created.')
chanServiceRateOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanServiceRateOverride.setStatus('current')
if mibBuilder.loadTexts: chanServiceRateOverride.setDescription('This variable sets the SAR IR programming option. Foresight and chanServiceRateOverride are mutually exclusive. For FRSM12 Card: Not Supported.')
chanServiceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 6400000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanServiceRate.setStatus('current')
if mibBuilder.loadTexts: chanServiceRate.setDescription('This is the rate to which IR can be set to when chanServiceRateOverride is set to enable(1). If chanServiceRateOverride is disable(2) then this object does not have any significance. For FRSM-8T1/8E1,this is defined in fastpackets/sec. For FRSM-VHS, this is defined in atm cells per second. For VHS the range in cells per second will be 10 to 400000 cps. For FRSM12 Card: Not Supported.')
zeroCirConEir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zeroCirConEir.setStatus('current')
if mibBuilder.loadTexts: zeroCirConEir.setDescription("The value of this object defines defines EIR value for '0' CIR connection. If the value is '0', EIR is set to port speed. If zeroCirConEir is non-zero value, EIR is set to value of this object, and this value is used for policing in ingress direction. This object is valid only for a zero cir connection. zeroCirConEir has to be less than or equal to the port speed.")
chanReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanReroute.setStatus('current')
if mibBuilder.loadTexts: chanReroute.setDescription(' This is used by the administrator to trigger the re-routing of the connection. The rerouting takes effect, when this object is set to true(1). When set to false (2), no action is taken. A get on this object always returns false (2). This object is not applicable to MGX Release 1.x. ')
frConnSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 60), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnSCR.setStatus('current')
if mibBuilder.loadTexts: frConnSCR.setDescription(' Sustained cell rate, Used for VBR connections setup with PNNI controller. For FRSM12 Card: Default value is frConnPCR This object is not applicable to MGX Release 1.x.')
frConnRemoteSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 61), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemoteSCR.setStatus('current')
if mibBuilder.loadTexts: frConnRemoteSCR.setDescription(' Sustained cell rate of the other end, Used for VBR connections setup with PNNI controller. For FRSM12 Card: Default value is frConnSCR This object is not applicable to MGX Release 1.x ')
frConnTemplateId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 62), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17)).clone(17)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnTemplateId.setStatus('current')
if mibBuilder.loadTexts: frConnTemplateId.setDescription('This object specifies the template identifier for the connection template associated with this connection. The valid range for templates is 1..16. A value of 17 indicates no template is associated with this connection For FRSM12 Card: Not Supported This object is not applicable to MGX Release 1.x ')
frConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnAdminStatus.setStatus('current')
if mibBuilder.loadTexts: frConnAdminStatus.setDescription('This object specifies channel admin status. This object is not applicable to MGX Release 1.x.')
frChanCnfChangeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 64), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frChanCnfChangeCount.setStatus('current')
if mibBuilder.loadTexts: frChanCnfChangeCount.setDescription('This object is added only for FRSM12 card. This counter tracks the number of configuration changes that happen on a channel. The counter is associated only with the end point and NOT with the connection itself. This counter is used by the NMS to determine if a connection configuration had been modified and requires an upload. This functionality is conventionally achieved by time stamping using a time-of-day clock. However, in switches where time-of-day clock is not available, the following scheme is used: The upload counter is incremented, when: * assignment of connection to an end point channel. This happens when a connection is added and assigned this channel number. * de-assignment of connection from a channel number. This happens when a connection is deleted and the end point resource is released. * When there is a configuration change done to the connection that is associated with this end point channel number. In a new system, an unutilised resouce (channel number) has a counter value of zero. When a connection is added to this channel end point, the counter is incremented. And is incremented for any of the above operations. When a connection is deleted the value of this counter is incremented and preserved till a new connection gets associated with this channel end point. This object is not applicable to MGX Release 1.x.')
frChanCnfIgnoreIncomingDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanCnfIgnoreIncomingDE.setStatus('current')
if mibBuilder.loadTexts: frChanCnfIgnoreIncomingDE.setDescription('This object is added for FRSM12 card. When this object is enabled, the incoming frames with DE(Discard Eligible) bit set to 1 are counted in the Bc bucket instead of Be bucket This object is not applicable to MGX Release 1.x.')
frChanOamCCEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanOamCCEnable.setStatus('current')
if mibBuilder.loadTexts: frChanOamCCEnable.setDescription('This object is added for FRSM12 card. This object serves to enable or disable continuity check(CC) on a connection endpoint. When continuity check is enabled on an endpoint, the endpoint anticipates OAM CC cells from its peer endpoint. OAM CC cells are sent when the peer endpoint does not have traffic cells to send. If the connection is idle and this endpoint has not received OAM CC cells for a period of 3.5 +/- 0.5 seconds, it declares continuity failure. This object serves to administratively control the CC feature. Typical implementations (of this feature) may choose to ignore this control or impose other conditions to actually enable CC cell flow. However, if this object is set to false(2), then this feature should be disabled This object is not applicable to MGX Release 1.x.')
frChanStatsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanStatsEnable.setStatus('current')
if mibBuilder.loadTexts: frChanStatsEnable.setDescription(' This object serves the purpose of enabling/disabling statistics collection on a per connection basis. In implementations which do not have such limitations, this object can be set to enable(1) for all connections. Limits imposed by software or hardware implementations could restrict the amount of statistical data that can be maintained in a physical entity (like a service module card). Hence there could be a need to restrict statistics collection to a smaller subset. This object is not applicable to MGX Release 1.x.')
frChanLocalLpbkEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanLocalLpbkEnable.setStatus('current')
if mibBuilder.loadTexts: frChanLocalLpbkEnable.setDescription('This object is added for FRSM12 card. This object when enabled adds a channel-level loopback towards the port side. If the connection is in loopback, Connection MIB (FrChanCnfGrpEntry) variables cannot be modified. This object is not applicable to MGX Release 1.x. ')
frChanUpcEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanUpcEnable.setStatus('current')
if mibBuilder.loadTexts: frChanUpcEnable.setDescription(' This object is added for FRSM12 card. This object when disabled, disables Frame Relay policing. This object is not applicable to MGX Release 1.x. ')
frChanSlaveType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("persistentSlave", 1), ("nonPersistentSlave", 2))).clone('persistentSlave')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanSlaveType.setStatus('current')
if mibBuilder.loadTexts: frChanSlaveType.setDescription("This object is added for FRSM12 card. This object indicates whether a master endpoint has a persistent slave or not. A connection with a master and a non-persistent slave is considered a single-ended SPVC. This object is only meaningful when 'frMastership' contains the value of 'master(1)'. And this variable must be used with 'frMastership' to decide if a connection is single-ended or not. This object is not applicable to MGX Release 1.x.")
frConnRemoteMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 71), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000000)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemoteMBS.setStatus('current')
if mibBuilder.loadTexts: frConnRemoteMBS.setDescription("Remote Maximum Burst Size in terms of number of cells. This object should be set by the user in cases when the remote end of the connection is an ATM end-point where the Local MBS can be explicitly specified. In such cases, this element should be set to be equal to the remote end-point's local MBS. This object is not applicable to MGX Release 1.x. ")
frChanPrefRouteId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 72), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanPrefRouteId.setStatus('current')
if mibBuilder.loadTexts: frChanPrefRouteId.setDescription("This object serves to to associate a preferred route with a connection. The value '0' means no preferred route is associated with this connection. Usage: - If the value of this set to 0, the object frChanDirectRoute is automatically set to FALSE by the switch. - The preferred route is defined in cwaPrefRouteConfTable object.")
frChanDirectRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 73), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanDirectRoute.setStatus('current')
if mibBuilder.loadTexts: frChanDirectRoute.setDescription('This object serves to associate a prefer route as directed route (correspond to the prefer route object frChanPrefRouteId). A directed route specifies that the associated preferred route is the only permission route for the connection to take. Should the associated preferred route be unavailable, the connection is failed. The object is not applicable if there is no associated preferred route with the connection.')
chanNumNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanNumNextAvailable.setStatus('current')
if mibBuilder.loadTexts: chanNumNextAvailable.setDescription("This variable contains the next UNUSED channel number of the maximum possible value(depends upon the service module). This number can be used in channel config table, the ChanNumNextAvailable gets updated if the number gets used to create a logical channel. A '0' indicates that no more channels are available. For FRSM12 Card: Not Supported.")
frstdABRCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3), )
if mibBuilder.loadTexts: frstdABRCnfGrpTable.setStatus('current')
if mibBuilder.loadTexts: frstdABRCnfGrpTable.setDescription('This table is used for configuring ABR parameters on a frame relay connection. ')
frstdABRCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1), ).setIndexNames((0, "CISCO-WAN-FR-CONN-MIB", "frstdABRcnfChanNum"))
if mibBuilder.loadTexts: frstdABRCnfGrpEntry.setStatus('current')
if mibBuilder.loadTexts: frstdABRCnfGrpEntry.setDescription('An entry in ABR Configuration table.')
frstdABRcnfChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frstdABRcnfChanNum.setStatus('current')
if mibBuilder.loadTexts: frstdABRcnfChanNum.setDescription('Refers to the virtual connection index. The value supported depends upon the type of service module. Supported Range for different Card Types: FRSM-4T1/E1 : supported range is 16..271 (256 entries) FRSM-8T1/E1 : supported range is 16..1015 (1000 entries) FRSM-T3/E3/HS2/ /HS2B-HSSI/T3B/E3B : supported range is 16..2015 (2000 entries) FRSM-2CT3/HS2B-12IN1: supported range is 16..4015 (4000 entries) FRSM12 Card: Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = channel Number. Lower two bytes range from 16..16015 (16000 entries) ')
frstdABRTBE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRTBE.setStatus('current')
if mibBuilder.loadTexts: frstdABRTBE.setDescription('The value of this object is equal to Transient Buffer Exposure(TBE). The TBE is a negotiated number of cells that the network would like to limit the source to sending during startup periods, before the first RM-cell returns.')
frstdABRFRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700))).setUnits('milli-seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRFRTT.setStatus('current')
if mibBuilder.loadTexts: frstdABRFRTT.setDescription('The value of this object is equal to Fixed Round-Trip Time(FRTT). The FRTT is sum of the fixed propogation delays from the source to a destination network. The Value 0 signifies that FRTT is not available.')
frstdABRRDF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRRDF.setStatus('current')
if mibBuilder.loadTexts: frstdABRRDF.setDescription('The value of this object is equal to Rate Decrease Factor(RDF). The RDF controls the rate decrease which occurs when backward RM-cells with CI=1 are received. Larger values lead to faster rate decrease. The value specified has to be inverted to arrive at the actual value. The valid values possible are only powers of 2; i.e. 1, 2, 4, 8 ..... 32768. The SNMP agent has to verify this compliance.')
frstdABRRIF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRRIF.setStatus('current')
if mibBuilder.loadTexts: frstdABRRIF.setDescription('The value of this object is equal to Rate Increase Factor(RIF). The RIF controls the rate increase which occurs when a backward RM-cell is received with CI=0 and NI=0. The value specified has to be inverted to arrive at the actual value. The valid values possible are only powers of 2; i.e. 1, 2, 4, 8 ..... 32768. The SNMP agent has to verify this compliance.')
frstdABRNrm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 256)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRNrm.setStatus('current')
if mibBuilder.loadTexts: frstdABRNrm.setDescription('The value of this object is equal to number of cells a source may send for each forward RM cell. The valid values possible are only powers of 2 starting from 2; i.e. 2, 4, 8 ..... 256. The SNMP agent has to verify this compliance.')
frstdABRTrm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 255)).clone(255)).setUnits('milli-seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRTrm.setStatus('current')
if mibBuilder.loadTexts: frstdABRTrm.setDescription('The value of this object is equal to Upper bound on the time between forward RM cells for an active source.')
frstdABRCDF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRCDF.setStatus('current')
if mibBuilder.loadTexts: frstdABRCDF.setDescription('The value of this object is equal to Cutoff Decrease Factor(CDF). The value specified has to be inverted to arrive at the actual value. The valid values possible are 0 and only powers of 2; i.e., 1, 2, 4, 8, 16, 32, 64. The SNMP agent has to verify this compliance.')
frstdABRADTF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10230)).clone(500)).setUnits('milli-seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRADTF.setStatus('current')
if mibBuilder.loadTexts: frstdABRADTF.setDescription('The value of this object is equal to ACR Decrease Time Factor(ADTF). The Granularity allowed is 10 milli seconds. i.e. 10,20,30 etc. The SNMP agent has to verify this compliance.')
frstdABRICR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 400000)).clone(10)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRICR.setStatus('current')
if mibBuilder.loadTexts: frstdABRICR.setDescription('The value of this object is equal to Initial Cell Rate(ICR). The ICR is the rate at which the source should send initially and after an idle period. This includes the bandwidth allocated for both data cells as well as all in-rate RM cells.')
frstdABRMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 400000)).clone(10)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRMCR.setStatus('current')
if mibBuilder.loadTexts: frstdABRMCR.setDescription('The value of this object is equal to Minimum Cell Rate(MCR). The MCR is the rate at which the source is allowed to send. This includes the bandwidth allocated for both data cells as well as all in-rate RM cells.')
frstdABRPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 400000)).clone(10)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRPCR.setStatus('current')
if mibBuilder.loadTexts: frstdABRPCR.setDescription('The value of this object is equal to Peak Cell Rate(PCR). The PCR is the rate at which the source is allowed to send. This includes the bandwidth allocated for both data cells as well as all in-rate RM cells.')
frChanStateGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2))
frChanStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1), )
if mibBuilder.loadTexts: frChanStateGrpTable.setStatus('current')
if mibBuilder.loadTexts: frChanStateGrpTable.setDescription('Table of transmit/receive states of channels.')
frChanStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-FR-CONN-MIB", "stateChanNum"))
if mibBuilder.loadTexts: frChanStateGrpEntry.setStatus('current')
if mibBuilder.loadTexts: frChanStateGrpEntry.setDescription('An entry for FrChannelStateGrpEntry.')
stateChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stateChanNum.setStatus('current')
if mibBuilder.loadTexts: stateChanNum.setDescription("The value of this object refers to frame relay connection. The value must be same as the value of the object 'chanNum' in frChanCnfGrpTable.")
chanState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notConfigured", 1), ("okay", 2), ("alarm", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanState.setStatus('current')
if mibBuilder.loadTexts: chanState.setDescription('This variable indicates the LMI state of the VC (channel). The possible values are : notConfigured(1): Connection Not configured okay(2) : Connection is in Ok state alarm(3) : Connection is in alarm failed(4) : Connection is in failed state. This is applicable only for PNNI.')
xmtAbitState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("sendingAequal1", 2), ("sendingAequal0", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtAbitState.setStatus('current')
if mibBuilder.loadTexts: xmtAbitState.setDescription('The value of this object identifies the A bit transmit state. The possible values are : off(1) : LMI is off sendingAequal1(2) : LMI is on and connection is O.K. sendingAequal0(3) : LMI is on and connection is failed.')
rcvAbitState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("rcvingAequal1", 2), ("rcvingAequal0", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvAbitState.setStatus('current')
if mibBuilder.loadTexts: rcvAbitState.setDescription('The value of this object identifies the A bit receive state. The possible values are : off(1) : LMI is off rcvingAequal1(2) : LMI is on and connection is O.K. rcvingAequal0(3) : LMI is on and connection is failed.')
xmtATMState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSending", 1), ("sendingAIS", 2), ("sendingFERF", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtATMState.setStatus('current')
if mibBuilder.loadTexts: xmtATMState.setDescription('This variable indicates the transmit state of the VC (channel) on the ATM side. The possible values are : notSending(1) : Not sending any state sendingAIS(2) : Sending AIS OAM state sendingFERF(2) : Sending FERF OAM state.')
rcvATMState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notRcving", 1), ("rcvingAIS", 2), ("rcvingFERF", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvATMState.setStatus('current')
if mibBuilder.loadTexts: rcvATMState.setDescription('This variable indicates the receive state of the VC (channel) on the ATM side. The possible values are : notRcving(1) : Not receiving any state rcvingAIS(2) : Receiving AIS OAM rcvingFERF(2) : Receiving FERF OAM.')
chanStatusBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanStatusBitMap.setStatus('current')
if mibBuilder.loadTexts: chanStatusBitMap.setDescription('This variable indicates the consolidated bit map of the channel alarm state. Individual bit positions are as defined below. Bit position Fail/Alarm Reason ------------ ---------- ------ 0 Alarm Reserved 1 Alarm n/w side AIS/RDI Rx 2 Fail Conditioned(A bit from n/w) 3 Alarm Reserved 4 Fail CC failed/RAS failed 5 Fail Mismatch 6 Alarm ingress A bit (LMI) 7 Alarm Reserved Fail bitmap mask : 0x34 Alarm bitmap mask: 0xCB This object is not applicable to MGX Release 1.x. ')
frEndPtMapGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3))
frEndPtMapGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1), )
if mibBuilder.loadTexts: frEndPtMapGrpTable.setStatus('current')
if mibBuilder.loadTexts: frEndPtMapGrpTable.setDescription('This is the Endpoint Mapping table for Frame Relay connections.')
frEndPtMapGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-FR-CONN-MIB", "endPortNum"), (0, "CISCO-WAN-FR-CONN-MIB", "endDLCI"))
if mibBuilder.loadTexts: frEndPtMapGrpEntry.setStatus('current')
if mibBuilder.loadTexts: frEndPtMapGrpEntry.setDescription('An entry in the frame relay connection Endpoint table.')
endPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endPortNum.setStatus('current')
if mibBuilder.loadTexts: endPortNum.setDescription("This object identifies the frame relay logical port. The value for this object must be same as 'portNum' object in frPortCnfPortGrpTable. If ifTable is is implemented in a service module, this object must be same as the ifIndex of frame relay port.")
endDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388607))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endDLCI.setStatus('current')
if mibBuilder.loadTexts: endDLCI.setDescription('The value of this object is equal to the DLCI value for this PVC endpoint.')
endChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endChanNum.setStatus('current')
if mibBuilder.loadTexts: endChanNum.setDescription("The value of this object identifies the frame relay connection number. The value of this object is same as the value of 'chanNum' object in frChanCnfGrpTable. This object contains value 0, if port.dlci is a multicast group.")
endLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endLineNum.setStatus('current')
if mibBuilder.loadTexts: endLineNum.setDescription('The value of this object is equal to the physical line(for example T1/E1) or ifIndex on which connection is provisioned. If ifTable is not implemented in a service module, then the range is from 1 to Maximum number of lines supported. If ifTable is is implemented in a service module, this object must be same as the ifIndex of the interface (ifType=ds1(18),ds3(30)). The value supported for this object depends upon the type of service module: FRSM-4T1/E1 : Range is from 1..4 FRSM-8T1/E1 : Range is from 1..8 FRSM-T3/E3/HS2: Range is from 1..2 FRSM-2CT3 : Range is from 1..56 with ifTable Support: must refer to ifIndex of the interface. ')
ciscoWanFrConnMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 47, 2))
ciscoWanFrConnMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 1))
ciscoWanFrConnMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 2))
ciscoWanFrConnCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 2, 1)).setObjects(("CISCO-WAN-FR-CONN-MIB", "ciscoWanFrConnGroup"), ("CISCO-WAN-FR-CONN-MIB", "ciscoWanFrConnTestGroup"), ("CISCO-WAN-FR-CONN-MIB", "ciscoWanFrConnStateGroup"), ("CISCO-WAN-FR-CONN-MIB", "ciscoWanFrConnEndptGroup"), ("CISCO-WAN-FR-CONN-MIB", "ciscoWanFrConnABRGroup"), ("CISCO-WAN-FR-CONN-MIB", "ciscoWanFrConnForesightGroup"), ("CISCO-WAN-FR-CONN-MIB", "ciscoWanFrConnQueueGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrConnCompliance = ciscoWanFrConnCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrConnCompliance.setDescription('The compliance statement for SNMP entities which support Frame realy connection MIB.')
ciscoWanFrConnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 1, 1)).setObjects(("CISCO-WAN-FR-CONN-MIB", "chanNum"), ("CISCO-WAN-FR-CONN-MIB", "chanRowStatus"), ("CISCO-WAN-FR-CONN-MIB", "chanPortNum"), ("CISCO-WAN-FR-CONN-MIB", "dLCI"), ("CISCO-WAN-FR-CONN-MIB", "egressQSelect"), ("CISCO-WAN-FR-CONN-MIB", "deTaggingEnable"), ("CISCO-WAN-FR-CONN-MIB", "cir"), ("CISCO-WAN-FR-CONN-MIB", "bc"), ("CISCO-WAN-FR-CONN-MIB", "be"), ("CISCO-WAN-FR-CONN-MIB", "ibs"), ("CISCO-WAN-FR-CONN-MIB", "chanLocRmtLpbkState"), ("CISCO-WAN-FR-CONN-MIB", "chanType"), ("CISCO-WAN-FR-CONN-MIB", "chanFECNconfig"), ("CISCO-WAN-FR-CONN-MIB", "chanDEtoCLPmap"), ("CISCO-WAN-FR-CONN-MIB", "chanCLPtoDEmap"), ("CISCO-WAN-FR-CONN-MIB", "chanIngrPercentUtil"), ("CISCO-WAN-FR-CONN-MIB", "chanEgrPercentUtil"), ("CISCO-WAN-FR-CONN-MIB", "chanEgrSrvRate"), ("CISCO-WAN-FR-CONN-MIB", "chanOvrSubOvrRide"), ("CISCO-WAN-FR-CONN-MIB", "chanFrConnType"), ("CISCO-WAN-FR-CONN-MIB", "frCDRNumber"), ("CISCO-WAN-FR-CONN-MIB", "frLocalVpi"), ("CISCO-WAN-FR-CONN-MIB", "frLocalVci"), ("CISCO-WAN-FR-CONN-MIB", "frLocalNSAP"), ("CISCO-WAN-FR-CONN-MIB", "frRemoteVpi"), ("CISCO-WAN-FR-CONN-MIB", "frRemoteVci"), ("CISCO-WAN-FR-CONN-MIB", "frRemoteNSAP"), ("CISCO-WAN-FR-CONN-MIB", "frMastership"), ("CISCO-WAN-FR-CONN-MIB", "frVpcFlag"), ("CISCO-WAN-FR-CONN-MIB", "frConnServiceType"), ("CISCO-WAN-FR-CONN-MIB", "frRoutingPriority"), ("CISCO-WAN-FR-CONN-MIB", "frMaxCost"), ("CISCO-WAN-FR-CONN-MIB", "frRestrictTrunkType"), ("CISCO-WAN-FR-CONN-MIB", "frConnPCR"), ("CISCO-WAN-FR-CONN-MIB", "frConnRemotePCR"), ("CISCO-WAN-FR-CONN-MIB", "frConnMCR"), ("CISCO-WAN-FR-CONN-MIB", "frConnRemoteMCR"), ("CISCO-WAN-FR-CONN-MIB", "frConnPercentUtil"), ("CISCO-WAN-FR-CONN-MIB", "frConnRemotePercentUtil"), ("CISCO-WAN-FR-CONN-MIB", "frConnForeSightEnable"), ("CISCO-WAN-FR-CONN-MIB", "frConnFGCRAEnable"), ("CISCO-WAN-FR-CONN-MIB", "chanServType"), ("CISCO-WAN-FR-CONN-MIB", "chanServiceRateOverride"), ("CISCO-WAN-FR-CONN-MIB", "chanServiceRate"), ("CISCO-WAN-FR-CONN-MIB", "zeroCirConEir"), ("CISCO-WAN-FR-CONN-MIB", "chanReroute"), ("CISCO-WAN-FR-CONN-MIB", "frConnSCR"), ("CISCO-WAN-FR-CONN-MIB", "frConnRemoteSCR"), ("CISCO-WAN-FR-CONN-MIB", "frConnTemplateId"), ("CISCO-WAN-FR-CONN-MIB", "frConnAdminStatus"), ("CISCO-WAN-FR-CONN-MIB", "frChanCnfChangeCount"), ("CISCO-WAN-FR-CONN-MIB", "frChanCnfIgnoreIncomingDE"), ("CISCO-WAN-FR-CONN-MIB", "frChanOamCCEnable"), ("CISCO-WAN-FR-CONN-MIB", "frChanStatsEnable"), ("CISCO-WAN-FR-CONN-MIB", "frChanLocalLpbkEnable"), ("CISCO-WAN-FR-CONN-MIB", "frChanUpcEnable"), ("CISCO-WAN-FR-CONN-MIB", "frChanSlaveType"), ("CISCO-WAN-FR-CONN-MIB", "frConnRemoteMBS"), ("CISCO-WAN-FR-CONN-MIB", "chanNumNextAvailable"), ("CISCO-WAN-FR-CONN-MIB", "frChanPrefRouteId"), ("CISCO-WAN-FR-CONN-MIB", "frChanDirectRoute"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrConnGroup = ciscoWanFrConnGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrConnGroup.setDescription('A collection of objects providing information applicable to a Frame Relay Connection.')
ciscoWanFrConnForesightGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 1, 2)).setObjects(("CISCO-WAN-FR-CONN-MIB", "foreSightEnable"), ("CISCO-WAN-FR-CONN-MIB", "qir"), ("CISCO-WAN-FR-CONN-MIB", "mir"), ("CISCO-WAN-FR-CONN-MIB", "pir"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrConnForesightGroup = ciscoWanFrConnForesightGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrConnForesightGroup.setDescription('A collection of objects related to foresight feature of a frame realay connection.')
ciscoWanFrConnQueueGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 1, 3)).setObjects(("CISCO-WAN-FR-CONN-MIB", "ingressQDepth"), ("CISCO-WAN-FR-CONN-MIB", "ingressQDEThresh"), ("CISCO-WAN-FR-CONN-MIB", "ingressQECNThresh"), ("CISCO-WAN-FR-CONN-MIB", "egressQDepth"), ("CISCO-WAN-FR-CONN-MIB", "egressQDEThresh"), ("CISCO-WAN-FR-CONN-MIB", "egressQECNThresh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrConnQueueGroup = ciscoWanFrConnQueueGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrConnQueueGroup.setDescription('A collection of objects related to queue depth egress/ingress thresholds.')
ciscoWanFrConnTestGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 1, 4)).setObjects(("CISCO-WAN-FR-CONN-MIB", "chanTestType"), ("CISCO-WAN-FR-CONN-MIB", "chanTestState"), ("CISCO-WAN-FR-CONN-MIB", "chanRTDResult"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrConnTestGroup = ciscoWanFrConnTestGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrConnTestGroup.setDescription('A collection of objects related to testing Frame relay connections.')
ciscoWanFrConnStateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 1, 5)).setObjects(("CISCO-WAN-FR-CONN-MIB", "stateChanNum"), ("CISCO-WAN-FR-CONN-MIB", "chanState"), ("CISCO-WAN-FR-CONN-MIB", "xmtAbitState"), ("CISCO-WAN-FR-CONN-MIB", "rcvAbitState"), ("CISCO-WAN-FR-CONN-MIB", "xmtATMState"), ("CISCO-WAN-FR-CONN-MIB", "rcvATMState"), ("CISCO-WAN-FR-CONN-MIB", "chanStatusBitMap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrConnStateGroup = ciscoWanFrConnStateGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrConnStateGroup.setDescription('A collection of objects related to state of Frame Relay connections.')
ciscoWanFrConnEndptGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 1, 6)).setObjects(("CISCO-WAN-FR-CONN-MIB", "endPortNum"), ("CISCO-WAN-FR-CONN-MIB", "endDLCI"), ("CISCO-WAN-FR-CONN-MIB", "endChanNum"), ("CISCO-WAN-FR-CONN-MIB", "endLineNum"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrConnEndptGroup = ciscoWanFrConnEndptGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrConnEndptGroup.setDescription('A collection of objects related to Endpoint mapping in Frame Relay Connections.')
ciscoWanFrConnABRGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 47, 2, 1, 7)).setObjects(("CISCO-WAN-FR-CONN-MIB", "frstdABRcnfChanNum"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRTBE"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRFRTT"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRRDF"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRRIF"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRNrm"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRTrm"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRCDF"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRADTF"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRICR"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRMCR"), ("CISCO-WAN-FR-CONN-MIB", "frstdABRPCR"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoWanFrConnABRGroup = ciscoWanFrConnABRGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoWanFrConnABRGroup.setDescription('A collection of objects related to ABR in a frame relay connection.')
mibBuilder.exportSymbols("CISCO-WAN-FR-CONN-MIB", ciscoWanFrConnMIBGroups=ciscoWanFrConnMIBGroups, frCDRNumber=frCDRNumber, frChanStateGrpEntry=frChanStateGrpEntry, frChanStatsEnable=frChanStatsEnable, chanServType=chanServType, frConnRemotePCR=frConnRemotePCR, chanDEtoCLPmap=chanDEtoCLPmap, frLocalNSAP=frLocalNSAP, stateChanNum=stateChanNum, frConnSCR=frConnSCR, chanServiceRate=chanServiceRate, frstdABRNrm=frstdABRNrm, ciscoWanFrConnCompliance=ciscoWanFrConnCompliance, qir=qir, ciscoWanFrConnQueueGroup=ciscoWanFrConnQueueGroup, frChanCnfGrpEntry=frChanCnfGrpEntry, frChanLocalLpbkEnable=frChanLocalLpbkEnable, frstdABRCDF=frstdABRCDF, frChanCnfGrp=frChanCnfGrp, ciscoWanFrConnStateGroup=ciscoWanFrConnStateGroup, frstdABRRDF=frstdABRRDF, be=be, xmtATMState=xmtATMState, frRoutingPriority=frRoutingPriority, frstdABRTrm=frstdABRTrm, chanEgrPercentUtil=chanEgrPercentUtil, foreSightEnable=foreSightEnable, chanPortNum=chanPortNum, chanFECNconfig=chanFECNconfig, frConnRemotePercentUtil=frConnRemotePercentUtil, chanServiceRateOverride=chanServiceRateOverride, PYSNMP_MODULE_ID=ciscoWanFrConnMIB, frEndPtMapGrp=frEndPtMapGrp, frstdABRMCR=frstdABRMCR, frstdABRTBE=frstdABRTBE, ciscoWanFrConnTestGroup=ciscoWanFrConnTestGroup, frstdABRcnfChanNum=frstdABRcnfChanNum, bc=bc, egressQDepth=egressQDepth, frEndPtMapGrpTable=frEndPtMapGrpTable, frRemoteVci=frRemoteVci, chanTestType=chanTestType, frstdABRRIF=frstdABRRIF, frMaxCost=frMaxCost, chanEgrSrvRate=chanEgrSrvRate, frChanCnfGrpTable=frChanCnfGrpTable, frConnPercentUtil=frConnPercentUtil, ciscoWanFrConnEndptGroup=ciscoWanFrConnEndptGroup, ciscoWanFrConnMIBCompliances=ciscoWanFrConnMIBCompliances, frConnTemplateId=frConnTemplateId, ingressQDEThresh=ingressQDEThresh, ciscoWanFrConnABRGroup=ciscoWanFrConnABRGroup, mir=mir, xmtAbitState=xmtAbitState, frRemoteVpi=frRemoteVpi, ingressQDepth=ingressQDepth, frChanUpcEnable=frChanUpcEnable, chanFrConnType=chanFrConnType, chanRowStatus=chanRowStatus, egressQDEThresh=egressQDEThresh, egressQSelect=egressQSelect, chanNum=chanNum, rcvAbitState=rcvAbitState, ibs=ibs, endDLCI=endDLCI, ciscoWanFrConnMIB=ciscoWanFrConnMIB, frstdABRCnfGrpEntry=frstdABRCnfGrpEntry, frChanDirectRoute=frChanDirectRoute, frChanSlaveType=frChanSlaveType, frRestrictTrunkType=frRestrictTrunkType, frConnServiceType=frConnServiceType, frstdABRPCR=frstdABRPCR, frstdABRADTF=frstdABRADTF, frEndPtMapGrpEntry=frEndPtMapGrpEntry, chanType=chanType, frMastership=frMastership, frLocalVpi=frLocalVpi, frConnRemoteSCR=frConnRemoteSCR, pir=pir, frConnAdminStatus=frConnAdminStatus, frConnRemoteMBS=frConnRemoteMBS, frChanOamCCEnable=frChanOamCCEnable, chanReroute=chanReroute, chanNumNextAvailable=chanNumNextAvailable, chanTestState=chanTestState, frChanCnfChangeCount=frChanCnfChangeCount, frLocalVci=frLocalVci, frChanPrefRouteId=frChanPrefRouteId, frstdABRICR=frstdABRICR, frstdABRFRTT=frstdABRFRTT, chanLocRmtLpbkState=chanLocRmtLpbkState, ciscoWanFrConnForesightGroup=ciscoWanFrConnForesightGroup, ciscoWanFrConnMIBConformance=ciscoWanFrConnMIBConformance, dLCI=dLCI, frConnRemoteMCR=frConnRemoteMCR, chanState=chanState, frVpcFlag=frVpcFlag, chanRTDResult=chanRTDResult, frConnMCR=frConnMCR, cir=cir, frConnForeSightEnable=frConnForeSightEnable, rcvATMState=rcvATMState, chanStatusBitMap=chanStatusBitMap, frConnFGCRAEnable=frConnFGCRAEnable, frRemoteNSAP=frRemoteNSAP, zeroCirConEir=zeroCirConEir, frChanStateGrpTable=frChanStateGrpTable, egressQECNThresh=egressQECNThresh, chanOvrSubOvrRide=chanOvrSubOvrRide, deTaggingEnable=deTaggingEnable, chanCLPtoDEmap=chanCLPtoDEmap, chanIngrPercentUtil=chanIngrPercentUtil, frConnPCR=frConnPCR, frChanCnfIgnoreIncomingDE=frChanCnfIgnoreIncomingDE, endChanNum=endChanNum, endLineNum=endLineNum, ingressQECNThresh=ingressQECNThresh, frChanStateGrp=frChanStateGrp, endPortNum=endPortNum, ciscoWanFrConnGroup=ciscoWanFrConnGroup, frstdABRCnfGrpTable=frstdABRCnfGrpTable)
